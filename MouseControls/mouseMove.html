<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Space 3D mouse movements</title>
</head>
<body>
	<script src="../../../three.min.js"></script>
	<script>
		var scene, camera, renderer;
		var projector;
		var focus = new THREE.Vector3();
		//will store all of the cubes
		var cubes = new THREE.Object3D();

		//randomize position for cubes
		function setPosition(cube){
			cube.position.x = Math.random() * (20);
			cube.position.y = Math.random() * (40 - 20) + 15;
			cube.position.z = Math.random() * 20;
		}

		init();
		animate();

		function init(){
			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.z = 45;
			camera.position.x = 10;
			camera.position.y = 25;
			
			for(var i = 0; i < 10; i++){
				var c = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshLambertMaterial(0x96C2FF));
				setPosition(c);
				cubes.add(c);

				if(i == 4){
					focus.copy(c.position);
				}
			}

			
			//adding the single 3D object will also add all of the children to the scene
			scene.add(cubes);

			var light = new THREE.AmbientLight(0x9769FB);
			light.position.set(1,1,10);
			scene.add(light);
			light = new THREE.DirectionalLight(0xffffff);
			scene.add(light);

			renderer = new THREE.WebGLRenderer({ antialias:false});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);	
			
			projector = new THREE.Projector();

			//event listeners
			window.addEventListener('resize', onWindowResize, false);
			document.addEventListener('mousedown', onMouseDown, false);
		}
		
		//listens for mouse press
		function onMouseDown(event){
			event.preventDefault();
			
			//gets location of mouse upon click
			var vector = new THREE.Vector3((event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);

       			projector.unprojectVector(vector, camera);

     			var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
     			var intersects = raycaster.intersectObjects(cubes.children);

     			if (intersects.length > 0) {
				alert("Hit");
				focus.copy(intersects[0].object.position);
			}
		} 

		function onWindowResize(){
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			render();
		}

		function render(){
			scene.updateMatrixWorld();
			renderer.render(scene,camera);
		}

		//animate scene
		function animate(){
			requestAnimationFrame(animate);
			var x = camera.position.x,
			    z = camera.position.z;
			var rotSpeed = .02;

			camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
			camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);

			camera.lookAt(focus);
			render();
		}
	</script>
</body>
</html>
